import { ApiBase } from './base'
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class AccountClient extends ApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost:50000";
    }

    /**
     * Authenticate and receive a JWT bearer token
     * @return Account retrieved
     */
    authenticate(authentication: AccountAuthentication): Promise<AuthenticationToken> {
        let url_ = this.baseUrl + "/account/authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(authentication);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAuthenticate(_response);
        });
    }

    protected processAuthenticate(response: Response): Promise<AuthenticationToken> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticationToken.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AuthenticationToken>(null as any);
    }

    /**
     * Reauthenticate to the local database using a refresh token instead of a password
     * @return Account retrieved
     */
    authenticateRefresh(authentication: AccountAuthenticationRefresh): Promise<AuthenticationToken> {
        let url_ = this.baseUrl + "/account/authenticate/refresh";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(authentication);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAuthenticateRefresh(_response);
        });
    }

    protected processAuthenticateRefresh(response: Response): Promise<AuthenticationToken> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticationToken.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AuthenticationToken>(null as any);
    }

    /**
     * Authorize access to API resources by authenticating to Google using OAuth 2.0
     * @return Account retrieved
     */
    authenticateGoogle(authentication: GoogleAccountAuthentication): Promise<AuthenticationToken> {
        let url_ = this.baseUrl + "/account/authenticate/google";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(authentication);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAuthenticateGoogle(_response);
        });
    }

    protected processAuthenticateGoogle(response: Response): Promise<AuthenticationToken> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticationToken.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AuthenticationToken>(null as any);
    }

    /**
     * Retrieve the account associated with the current JWT access token
     * @return Account retrieved
     */
    me(): Promise<Account> {
        let url_ = this.baseUrl + "/account/me";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processMe(_response);
        });
    }

    protected processMe(response: Response): Promise<Account> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Account.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Account>(null as any);
    }

    /**
     * Confirm an account via the welcome email workflow
     * @param dto An account confirmation DTO
     * @return Account confirmed
     */
    confirm(dto: AccountConfirmation): Promise<void> {
        let url_ = this.baseUrl + "/account/confirm";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processConfirm(_response);
        });
    }

    protected processConfirm(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Request an URL to be sent to the email address on record, allowing a password reset
     * @param dto A PasswordResetRequest dto containing the account's email address
     * @return Account confirmed
     */
    requestResetPassword(dto: PasswordResetRequest): Promise<void> {
        let url_ = this.baseUrl + "/account/password/reset";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRequestResetPassword(_response);
        });
    }

    protected processRequestResetPassword(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Accept magic URL token and new password for password reset workflow
     * @param dto A PasswordReset DTO
     * @return Account confirmed
     */
    resetPassword(dto: PasswordReset): Promise<void> {
        let url_ = this.baseUrl + "/account/password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processResetPassword(_response);
        });
    }

    protected processResetPassword(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class AdministratorClient extends ApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost:50000";
    }

    /**
     * @return Array of Claim DTOs
     */
    getClaims(): Promise<Claim[]> {
        let url_ = this.baseUrl + "/administrator/claim/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetClaims(_response);
        });
    }

    protected processGetClaims(response: Response): Promise<Claim[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Claim.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Claim[]>(null as any);
    }

    /**
     * @return Array of Claim DTOs
     */
    getClaimsByCustomer(customerUniqueID: string): Promise<Claim[]> {
        let url_ = this.baseUrl + "/administrator/customer/{customerUniqueID}/claim/all";
        if (customerUniqueID === undefined || customerUniqueID === null)
            throw new Error("The parameter 'customerUniqueID' must be defined.");
        url_ = url_.replace("{customerUniqueID}", encodeURIComponent("" + customerUniqueID));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetClaimsByCustomer(_response);
        });
    }

    protected processGetClaimsByCustomer(response: Response): Promise<Claim[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Claim.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Claim[]>(null as any);
    }

    /**
     * @return Array of Customer DTOs
     */
    getCustomers(): Promise<Customer[]> {
        let url_ = this.baseUrl + "/administrator/customer/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetCustomers(_response);
        });
    }

    protected processGetCustomers(response: Response): Promise<Customer[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Customer.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Customer[]>(null as any);
    }

    /**
     * @return Customer DTO
     */
    getCustomer(uniqueID: string): Promise<Customer> {
        let url_ = this.baseUrl + "/administrator/customer/{uniqueID}";
        if (uniqueID === undefined || uniqueID === null)
            throw new Error("The parameter 'uniqueID' must be defined.");
        url_ = url_.replace("{uniqueID}", encodeURIComponent("" + uniqueID));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetCustomer(_response);
        });
    }

    protected processGetCustomer(response: Response): Promise<Customer> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Customer.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Customer>(null as any);
    }

    /**
     * Update an existing customer
     * @param uniqueID The customer's unique public ID
     * @param dto A Customer DTO
     */
    updateCustomer(uniqueID: string, dto: CustomerCreateOrUpdate): Promise<Customer> {
        let url_ = this.baseUrl + "/administrator/customer/{uniqueID}";
        if (uniqueID === undefined || uniqueID === null)
            throw new Error("The parameter 'uniqueID' must be defined.");
        url_ = url_.replace("{uniqueID}", encodeURIComponent("" + uniqueID));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateCustomer(_response);
        });
    }

    protected processUpdateCustomer(response: Response): Promise<Customer> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Customer.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Customer>(null as any);
    }

    /**
     * Create a new customer
     * @param dto A Customer DTO
     */
    createCustomer(dto: CustomerCreateOrUpdate): Promise<Customer> {
        let url_ = this.baseUrl + "/administrator/customer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateCustomer(_response);
        });
    }

    protected processCreateCustomer(response: Response): Promise<Customer> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Customer.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Customer>(null as any);
    }

    /**
     * @return Array of Investigator DTOs
     */
    getInvestigators(): Promise<Investigator[]> {
        let url_ = this.baseUrl + "/administrator/investigator/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetInvestigators(_response);
        });
    }

    protected processGetInvestigators(response: Response): Promise<Investigator[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Investigator.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Investigator[]>(null as any);
    }

    /**
     * @return Investigator DTO
     */
    getInvestigator(uniqueID: string): Promise<Investigator> {
        let url_ = this.baseUrl + "/administrator/investigator/{uniqueID}";
        if (uniqueID === undefined || uniqueID === null)
            throw new Error("The parameter 'uniqueID' must be defined.");
        url_ = url_.replace("{uniqueID}", encodeURIComponent("" + uniqueID));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetInvestigator(_response);
        });
    }

    protected processGetInvestigator(response: Response): Promise<Investigator> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Investigator.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Investigator>(null as any);
    }

    /**
     * Update an existing investigator
     * @param uniqueID The investigator's unique public ID
     * @param dto An Investigator DTO
     */
    updateInvestigator(uniqueID: string, dto: InvestigatorCreateOrUpdate): Promise<Investigator> {
        let url_ = this.baseUrl + "/administrator/investigator/{uniqueID}";
        if (uniqueID === undefined || uniqueID === null)
            throw new Error("The parameter 'uniqueID' must be defined.");
        url_ = url_.replace("{uniqueID}", encodeURIComponent("" + uniqueID));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateInvestigator(_response);
        });
    }

    protected processUpdateInvestigator(response: Response): Promise<Investigator> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Investigator.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Investigator>(null as any);
    }

    /**
     * Create a new investigator
     * @param dto An Investigator DTO
     */
    createInvestigator(dto: InvestigatorCreateOrUpdate): Promise<Investigator> {
        let url_ = this.baseUrl + "/administrator/investigator";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateInvestigator(_response);
        });
    }

    protected processCreateInvestigator(response: Response): Promise<Investigator> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Investigator.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Investigator>(null as any);
    }

    /**
     * Retrieve a specific account by unique id
     * @param uniqueID The account's public unique ID
     * @return Account retrieved
     */
    get(uniqueID: string): Promise<Account> {
        let url_ = this.baseUrl + "/administrator/account/{uniqueID}";
        if (uniqueID === undefined || uniqueID === null)
            throw new Error("The parameter 'uniqueID' must be defined.");
        url_ = url_.replace("{uniqueID}", encodeURIComponent("" + uniqueID));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<Account> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Account.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Account>(null as any);
    }

    /**
     * Retrieve a specific account by email address
     * @param emailAddress (optional) The account's email address
     * @return Account retrieved
     */
    getByEmailAddress(emailAddress?: string | undefined): Promise<Account> {
        let url_ = this.baseUrl + "/administrator/account?";
        if (emailAddress === null)
            throw new Error("The parameter 'emailAddress' cannot be null.");
        else if (emailAddress !== undefined)
            url_ += "emailAddress=" + encodeURIComponent("" + emailAddress) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetByEmailAddress(_response);
        });
    }

    protected processGetByEmailAddress(response: Response): Promise<Account> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Account.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Account>(null as any);
    }

    /**
     * View a list of currently logged-in accounts
     * @return Account list
     */
    authenticated(): Promise<Account[]> {
        let url_ = this.baseUrl + "/administrator/account/authenticated";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAuthenticated(_response);
        });
    }

    protected processAuthenticated(response: Response): Promise<Account[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Account.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Account[]>(null as any);
    }
}

export class ContentClient extends ApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost:50000";
    }

    /**
     * Receives a notification when an email is opened (and image downloads are enabled)
     * @param uniqueID A system-wide unique ID for the given email message
     */
    setEmailReceived(uniqueID: string): Promise<FileResponse> {
        let url_ = this.baseUrl + "/content/email/{uniqueID}/received";
        if (uniqueID === undefined || uniqueID === null)
            throw new Error("The parameter 'uniqueID' must be defined.");
        url_ = url_.replace("{uniqueID}", encodeURIComponent("" + uniqueID));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSetEmailReceived(_response);
        });
    }

    protected processSetEmailReceived(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export class CustomerClient extends ApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost:50000";
    }

    /**
     * Create a new customer, via the self-service registration workflow
     * @param dto A CustomerRegistration DTO
     * @return Account retrieved
     */
    register(dto: CustomerRegistration): Promise<Customer> {
        let url_ = this.baseUrl + "/customer/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRegister(_response);
        });
    }

    protected processRegister(response: Response): Promise<Customer> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Customer.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Customer>(null as any);
    }
}

export class JobClient extends ApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost:50000";
    }

    /**
     * Get all scheduled jobs
     * @return List of all jobs
     */
    getAll(): Promise<Job[]> {
        let url_ = this.baseUrl + "/job/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<Job[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Job.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Job[]>(null as any);
    }

    /**
     * Run all pending jobs
     * @return All jobs were run, successfully or not
     */
    runPending(): Promise<void> {
        let url_ = this.baseUrl + "/job/runpending";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRunPending(_response);
        });
    }

    protected processRunPending(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class StatusClient extends ApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost:50000";
    }

    /**
     * Generate an unhandled exception
     */
    error(): Promise<void> {
        let url_ = this.baseUrl + "/status/error";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processError(_response);
        });
    }

    protected processError(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Generate a list of error codes
     */
    errorCode(): Promise<ErrorCode> {
        let url_ = this.baseUrl + "/status/errorcode";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processErrorCode(_response);
        });
    }

    protected processErrorCode(response: Response): Promise<ErrorCode> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ErrorCode>(null as any);
    }

    /**
     * Determine if the API is alive
     */
    ping(): Promise<boolean> {
        let url_ = this.baseUrl + "/status/ping";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPing(_response);
        });
    }

    protected processPing(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * Generate an unhandled exception
     */
    clearCache(): Promise<void> {
        let url_ = this.baseUrl + "/status/cache";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processClearCache(_response);
        });
    }

    protected processClearCache(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export abstract class Base implements IBase {

    constructor(data?: IBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): Base {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'Base' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IBase {
}

export class AuthenticationToken extends Base implements IAuthenticationToken {
    accessToken!: string;
    refreshToken!: string;
    validUntil!: Date;
    emailAddress!: string;
    role!: Role;

    constructor(data?: IAuthenticationToken) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.refreshToken = _data["refreshToken"];
            this.validUntil = _data["validUntil"] ? new Date(_data["validUntil"].toString()) : <any>undefined;
            this.emailAddress = _data["emailAddress"];
            this.role = _data["role"];
        }
    }

    static fromJS(data: any): AuthenticationToken {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticationToken();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["refreshToken"] = this.refreshToken;
        data["validUntil"] = this.validUntil ? this.validUntil.toISOString() : <any>undefined;
        data["emailAddress"] = this.emailAddress;
        data["role"] = this.role;
        super.toJSON(data);
        return data;
    }
}

export interface IAuthenticationToken extends IBase {
    accessToken: string;
    refreshToken: string;
    validUntil: Date;
    emailAddress: string;
    role: Role;
}

export enum Role {
    Administrator = "Administrator",
    Customer = "Customer",
    Investigator = "Investigator",
    Support = "Support",
}

export class AccountAuthentication extends Base implements IAccountAuthentication {
    emailAddress!: string;
    password!: string;

    constructor(data?: IAccountAuthentication) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.emailAddress = _data["emailAddress"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): AccountAuthentication {
        data = typeof data === 'object' ? data : {};
        let result = new AccountAuthentication();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        super.toJSON(data);
        return data;
    }
}

export interface IAccountAuthentication extends IBase {
    emailAddress: string;
    password: string;
}

export class AccountAuthenticationRefresh extends Base implements IAccountAuthenticationRefresh {
    emailAddress!: string;
    refreshToken!: string;

    constructor(data?: IAccountAuthenticationRefresh) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.emailAddress = _data["emailAddress"];
            this.refreshToken = _data["refreshToken"];
        }
    }

    static fromJS(data: any): AccountAuthenticationRefresh {
        data = typeof data === 'object' ? data : {};
        let result = new AccountAuthenticationRefresh();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        data["refreshToken"] = this.refreshToken;
        super.toJSON(data);
        return data;
    }
}

export interface IAccountAuthenticationRefresh extends IBase {
    emailAddress: string;
    refreshToken: string;
}

export class GoogleAccountAuthentication extends Base implements IGoogleAccountAuthentication {
    emailAddress!: string;
    googleJwt!: string;

    constructor(data?: IGoogleAccountAuthentication) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.emailAddress = _data["emailAddress"];
            this.googleJwt = _data["googleJwt"];
        }
    }

    static fromJS(data: any): GoogleAccountAuthentication {
        data = typeof data === 'object' ? data : {};
        let result = new GoogleAccountAuthentication();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        data["googleJwt"] = this.googleJwt;
        super.toJSON(data);
        return data;
    }
}

export interface IGoogleAccountAuthentication extends IBase {
    emailAddress: string;
    googleJwt: string;
}

export class Account extends Base implements IAccount {
    uniqueID!: string;
    role!: Role;
    identityProvider!: IdentityProvider;
    emailAddress!: string;
    avatarUrl!: string | undefined;
    authenticatedTimestamp!: Date | undefined;
    sessionAuthenticatedTimestamp!: Date | undefined;
    lastActiveTimestamp!: Date | undefined;
    emailAddressConfirmedTimestamp!: Date | undefined;

    constructor(data?: IAccount) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.uniqueID = _data["uniqueID"];
            this.role = _data["role"];
            this.identityProvider = _data["identityProvider"];
            this.emailAddress = _data["emailAddress"];
            this.avatarUrl = _data["avatarUrl"];
            this.authenticatedTimestamp = _data["authenticatedTimestamp"] ? new Date(_data["authenticatedTimestamp"].toString()) : <any>undefined;
            this.sessionAuthenticatedTimestamp = _data["sessionAuthenticatedTimestamp"] ? new Date(_data["sessionAuthenticatedTimestamp"].toString()) : <any>undefined;
            this.lastActiveTimestamp = _data["lastActiveTimestamp"] ? new Date(_data["lastActiveTimestamp"].toString()) : <any>undefined;
            this.emailAddressConfirmedTimestamp = _data["emailAddressConfirmedTimestamp"] ? new Date(_data["emailAddressConfirmedTimestamp"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Account {
        data = typeof data === 'object' ? data : {};
        let result = new Account();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["uniqueID"] = this.uniqueID;
        data["role"] = this.role;
        data["identityProvider"] = this.identityProvider;
        data["emailAddress"] = this.emailAddress;
        data["avatarUrl"] = this.avatarUrl;
        data["authenticatedTimestamp"] = this.authenticatedTimestamp ? this.authenticatedTimestamp.toISOString() : <any>undefined;
        data["sessionAuthenticatedTimestamp"] = this.sessionAuthenticatedTimestamp ? this.sessionAuthenticatedTimestamp.toISOString() : <any>undefined;
        data["lastActiveTimestamp"] = this.lastActiveTimestamp ? this.lastActiveTimestamp.toISOString() : <any>undefined;
        data["emailAddressConfirmedTimestamp"] = this.emailAddressConfirmedTimestamp ? this.emailAddressConfirmedTimestamp.toISOString() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IAccount extends IBase {
    uniqueID: string;
    role: Role;
    identityProvider: IdentityProvider;
    emailAddress: string;
    avatarUrl: string | undefined;
    authenticatedTimestamp: Date | undefined;
    sessionAuthenticatedTimestamp: Date | undefined;
    lastActiveTimestamp: Date | undefined;
    emailAddressConfirmedTimestamp: Date | undefined;
}

export enum IdentityProvider {
    Local = "Local",
    Google = "Google",
}

export class AccountConfirmation extends Base implements IAccountConfirmation {
    emailAddress!: string;
    token!: string;

    constructor(data?: IAccountConfirmation) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.emailAddress = _data["emailAddress"];
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): AccountConfirmation {
        data = typeof data === 'object' ? data : {};
        let result = new AccountConfirmation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        data["token"] = this.token;
        super.toJSON(data);
        return data;
    }
}

export interface IAccountConfirmation extends IBase {
    emailAddress: string;
    token: string;
}

export class PasswordResetRequest implements IPasswordResetRequest {
    emailAddress!: string;

    constructor(data?: IPasswordResetRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emailAddress = _data["emailAddress"];
        }
    }

    static fromJS(data: any): PasswordResetRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PasswordResetRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data;
    }
}

export interface IPasswordResetRequest {
    emailAddress: string;
}

export class PasswordReset extends Base implements IPasswordReset {
    emailAddress!: string;
    newPassword!: string;
    token!: string;

    constructor(data?: IPasswordReset) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.emailAddress = _data["emailAddress"];
            this.newPassword = _data["newPassword"];
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): PasswordReset {
        data = typeof data === 'object' ? data : {};
        let result = new PasswordReset();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        data["newPassword"] = this.newPassword;
        data["token"] = this.token;
        super.toJSON(data);
        return data;
    }
}

export interface IPasswordReset extends IBase {
    emailAddress: string;
    newPassword: string;
    token: string;
}

export class Claim implements IClaim {
    uniqueID!: string;
    type!: ClaimType;
    status!: ClaimStatus;
    disposition!: ClaimDisposition;
    externalID!: string;
    amountSubmitted!: number | undefined;
    amountAdjusted!: number | undefined;
    amountPaid!: number | undefined;
    eventDate!: Date;
    eventTime!: string | undefined;
    ingestedTimestamp!: Date | undefined;
    adjudicatedTimestamp!: Date | undefined;
    tombstonedTimestamp!: Date | undefined;
    attachments!: ClaimAttachment[];
    policy!: Policy;
    investigator!: Investigator | undefined;

    constructor(data?: IClaim) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.attachments) {
                this.attachments = [];
                for (let i = 0; i < data.attachments.length; i++) {
                    let item = data.attachments[i];
                    this.attachments[i] = item && !(<any>item).toJSON ? new ClaimAttachment(item) : <ClaimAttachment>item;
                }
            }
            this.policy = data.policy && !(<any>data.policy).toJSON ? new Policy(data.policy) : <Policy>this.policy;
            this.investigator = data.investigator && !(<any>data.investigator).toJSON ? new Investigator(data.investigator) : <Investigator>this.investigator;
        }
        if (!data) {
            this.attachments = [];
            this.policy = new Policy();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.uniqueID = _data["uniqueID"];
            this.type = _data["type"];
            this.status = _data["status"];
            this.disposition = _data["disposition"];
            this.externalID = _data["externalID"];
            this.amountSubmitted = _data["amountSubmitted"];
            this.amountAdjusted = _data["amountAdjusted"];
            this.amountPaid = _data["amountPaid"];
            this.eventDate = _data["eventDate"] ? new Date(_data["eventDate"].toString()) : <any>undefined;
            this.eventTime = _data["eventTime"];
            this.ingestedTimestamp = _data["ingestedTimestamp"] ? new Date(_data["ingestedTimestamp"].toString()) : <any>undefined;
            this.adjudicatedTimestamp = _data["adjudicatedTimestamp"] ? new Date(_data["adjudicatedTimestamp"].toString()) : <any>undefined;
            this.tombstonedTimestamp = _data["tombstonedTimestamp"] ? new Date(_data["tombstonedTimestamp"].toString()) : <any>undefined;
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments!.push(ClaimAttachment.fromJS(item));
            }
            this.policy = _data["policy"] ? Policy.fromJS(_data["policy"]) : new Policy();
            this.investigator = _data["investigator"] ? Investigator.fromJS(_data["investigator"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Claim {
        data = typeof data === 'object' ? data : {};
        let result = new Claim();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["uniqueID"] = this.uniqueID;
        data["type"] = this.type;
        data["status"] = this.status;
        data["disposition"] = this.disposition;
        data["externalID"] = this.externalID;
        data["amountSubmitted"] = this.amountSubmitted;
        data["amountAdjusted"] = this.amountAdjusted;
        data["amountPaid"] = this.amountPaid;
        data["eventDate"] = this.eventDate ? formatDate(this.eventDate) : <any>undefined;
        data["eventTime"] = this.eventTime;
        data["ingestedTimestamp"] = this.ingestedTimestamp ? this.ingestedTimestamp.toISOString() : <any>undefined;
        data["adjudicatedTimestamp"] = this.adjudicatedTimestamp ? this.adjudicatedTimestamp.toISOString() : <any>undefined;
        data["tombstonedTimestamp"] = this.tombstonedTimestamp ? this.tombstonedTimestamp.toISOString() : <any>undefined;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        data["policy"] = this.policy ? this.policy.toJSON() : <any>undefined;
        data["investigator"] = this.investigator ? this.investigator.toJSON() : <any>undefined;
        return data;
    }
}

export interface IClaim {
    uniqueID: string;
    type: ClaimType;
    status: ClaimStatus;
    disposition: ClaimDisposition;
    externalID: string;
    amountSubmitted: number | undefined;
    amountAdjusted: number | undefined;
    amountPaid: number | undefined;
    eventDate: Date;
    eventTime: string | undefined;
    ingestedTimestamp: Date | undefined;
    adjudicatedTimestamp: Date | undefined;
    tombstonedTimestamp: Date | undefined;
    attachments: IClaimAttachment[];
    policy: IPolicy;
    investigator: IInvestigator | undefined;
}

export enum ClaimType {
    Water = "Water",
    Fire = "Fire",
    Storm = "Storm",
    Theft = "Theft",
    Vandalism = "Vandalism",
    Mold = "Mold",
    Hail = "Hail",
    Other = "Other",
}

export enum ClaimStatus {
    Unassigned = "Unassigned",
    Investigating = "Investigating",
    Adjudicated = "Adjudicated",
    Resolved = "Resolved",
    Tombstoned = "Tombstoned",
}

export enum ClaimDisposition {
    Undecided = "Undecided",
    NotFraudulent = "NotFraudulent",
    Fraudulent = "Fraudulent",
}

export class ClaimAttachment implements IClaimAttachment {
    uniqueID!: string;
    type!: ClaimAttachmentType;
    path!: string;
    description!: string;
    summary!: string | undefined;
    originatedTimestamp!: Date | undefined;
    uploadedTimestamp!: Date;
    summarizedTimestamp!: Date | undefined;
    tombstonedTimestamp!: Date | undefined;

    constructor(data?: IClaimAttachment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.uniqueID = _data["uniqueID"];
            this.type = _data["type"];
            this.path = _data["path"];
            this.description = _data["description"];
            this.summary = _data["summary"];
            this.originatedTimestamp = _data["originatedTimestamp"] ? new Date(_data["originatedTimestamp"].toString()) : <any>undefined;
            this.uploadedTimestamp = _data["uploadedTimestamp"] ? new Date(_data["uploadedTimestamp"].toString()) : <any>undefined;
            this.summarizedTimestamp = _data["summarizedTimestamp"] ? new Date(_data["summarizedTimestamp"].toString()) : <any>undefined;
            this.tombstonedTimestamp = _data["tombstonedTimestamp"] ? new Date(_data["tombstonedTimestamp"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ClaimAttachment {
        data = typeof data === 'object' ? data : {};
        let result = new ClaimAttachment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["uniqueID"] = this.uniqueID;
        data["type"] = this.type;
        data["path"] = this.path;
        data["description"] = this.description;
        data["summary"] = this.summary;
        data["originatedTimestamp"] = this.originatedTimestamp ? this.originatedTimestamp.toISOString() : <any>undefined;
        data["uploadedTimestamp"] = this.uploadedTimestamp ? this.uploadedTimestamp.toISOString() : <any>undefined;
        data["summarizedTimestamp"] = this.summarizedTimestamp ? this.summarizedTimestamp.toISOString() : <any>undefined;
        data["tombstonedTimestamp"] = this.tombstonedTimestamp ? this.tombstonedTimestamp.toISOString() : <any>undefined;
        return data;
    }
}

export interface IClaimAttachment {
    uniqueID: string;
    type: ClaimAttachmentType;
    path: string;
    description: string;
    summary: string | undefined;
    originatedTimestamp: Date | undefined;
    uploadedTimestamp: Date;
    summarizedTimestamp: Date | undefined;
    tombstonedTimestamp: Date | undefined;
}

export enum ClaimAttachmentType {
    PDF = "PDF",
    MP4 = "MP4",
    JPG = "JPG",
    PNG = "PNG",
    DOCX = "DOCX",
    XLSX = "XLSX",
}

export class Policy implements IPolicy {
    uniqueID!: string;
    externalID!: string;
    bindingDate!: Date | undefined;
    startDate!: Date | undefined;
    endDate!: Date | undefined;
    deductible!: number | undefined;
    annualPremium!: number | undefined;
    claimsInLastYear!: number | undefined;
    claimsInLast3Years!: number | undefined;
    firstName!: string;
    lastName!: string;
    address!: string;
    address2!: string | undefined;
    city!: string;
    state!: string;
    postalCode!: string;
    telephone!: string;
    dateOfBirth!: Date | undefined;
    bedrooms!: number;
    bathrooms!: number | undefined;
    ownershipType!: OwnershipType | undefined;
    propertyType!: PropertyType | undefined;
    roofType!: RoofType | undefined;
    yearBuilt!: number | undefined;
    customer!: Customer;

    constructor(data?: IPolicy) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.customer = data.customer && !(<any>data.customer).toJSON ? new Customer(data.customer) : <Customer>this.customer;
        }
        if (!data) {
            this.customer = new Customer();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.uniqueID = _data["uniqueID"];
            this.externalID = _data["externalID"];
            this.bindingDate = _data["bindingDate"] ? new Date(_data["bindingDate"].toString()) : <any>undefined;
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.deductible = _data["deductible"];
            this.annualPremium = _data["annualPremium"];
            this.claimsInLastYear = _data["claimsInLastYear"];
            this.claimsInLast3Years = _data["claimsInLast3Years"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.address = _data["address"];
            this.address2 = _data["address2"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.postalCode = _data["postalCode"];
            this.telephone = _data["telephone"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.bedrooms = _data["bedrooms"];
            this.bathrooms = _data["bathrooms"];
            this.ownershipType = _data["ownershipType"];
            this.propertyType = _data["propertyType"];
            this.roofType = _data["roofType"];
            this.yearBuilt = _data["yearBuilt"];
            this.customer = _data["customer"] ? Customer.fromJS(_data["customer"]) : new Customer();
        }
    }

    static fromJS(data: any): Policy {
        data = typeof data === 'object' ? data : {};
        let result = new Policy();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["uniqueID"] = this.uniqueID;
        data["externalID"] = this.externalID;
        data["bindingDate"] = this.bindingDate ? formatDate(this.bindingDate) : <any>undefined;
        data["startDate"] = this.startDate ? formatDate(this.startDate) : <any>undefined;
        data["endDate"] = this.endDate ? formatDate(this.endDate) : <any>undefined;
        data["deductible"] = this.deductible;
        data["annualPremium"] = this.annualPremium;
        data["claimsInLastYear"] = this.claimsInLastYear;
        data["claimsInLast3Years"] = this.claimsInLast3Years;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["address"] = this.address;
        data["address2"] = this.address2;
        data["city"] = this.city;
        data["state"] = this.state;
        data["postalCode"] = this.postalCode;
        data["telephone"] = this.telephone;
        data["dateOfBirth"] = this.dateOfBirth ? formatDate(this.dateOfBirth) : <any>undefined;
        data["bedrooms"] = this.bedrooms;
        data["bathrooms"] = this.bathrooms;
        data["ownershipType"] = this.ownershipType;
        data["propertyType"] = this.propertyType;
        data["roofType"] = this.roofType;
        data["yearBuilt"] = this.yearBuilt;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPolicy {
    uniqueID: string;
    externalID: string;
    bindingDate: Date | undefined;
    startDate: Date | undefined;
    endDate: Date | undefined;
    deductible: number | undefined;
    annualPremium: number | undefined;
    claimsInLastYear: number | undefined;
    claimsInLast3Years: number | undefined;
    firstName: string;
    lastName: string;
    address: string;
    address2: string | undefined;
    city: string;
    state: string;
    postalCode: string;
    telephone: string;
    dateOfBirth: Date | undefined;
    bedrooms: number;
    bathrooms: number | undefined;
    ownershipType: OwnershipType | undefined;
    propertyType: PropertyType | undefined;
    roofType: RoofType | undefined;
    yearBuilt: number | undefined;
    customer: ICustomer;
}

export enum OwnershipType {
    OwnerOccupied = "OwnerOccupied",
    Rented = "Rented",
    Investment = "Investment",
}

export enum PropertyType {
    House = "House",
    Condominium = "Condominium",
}

export enum RoofType {
    Rolled = "Rolled",
    BUR = "BUR",
    Membrane = "Membrane",
    AsphaltShingles = "AsphaltShingles",
    Metal = "Metal",
    Shakes = "Shakes",
    Clay = "Clay",
    Concrete = "Concrete",
    Slate = "Slate",
    Other = "Other",
}

export class Customer implements ICustomer {
    uniqueID!: string;
    name!: string;
    firstName!: string;
    lastName!: string;
    code!: string;
    address!: string;
    address2!: string | undefined;
    city!: string;
    state!: string;
    postalCode!: string;
    telephone!: string;
    emailAddress!: string;
    avatarUrl!: string | undefined;

    constructor(data?: ICustomer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.uniqueID = _data["uniqueID"];
            this.name = _data["name"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.code = _data["code"];
            this.address = _data["address"];
            this.address2 = _data["address2"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.postalCode = _data["postalCode"];
            this.telephone = _data["telephone"];
            this.emailAddress = _data["emailAddress"];
            this.avatarUrl = _data["avatarUrl"];
        }
    }

    static fromJS(data: any): Customer {
        data = typeof data === 'object' ? data : {};
        let result = new Customer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["uniqueID"] = this.uniqueID;
        data["name"] = this.name;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["code"] = this.code;
        data["address"] = this.address;
        data["address2"] = this.address2;
        data["city"] = this.city;
        data["state"] = this.state;
        data["postalCode"] = this.postalCode;
        data["telephone"] = this.telephone;
        data["emailAddress"] = this.emailAddress;
        data["avatarUrl"] = this.avatarUrl;
        return data;
    }
}

export interface ICustomer {
    uniqueID: string;
    name: string;
    firstName: string;
    lastName: string;
    code: string;
    address: string;
    address2: string | undefined;
    city: string;
    state: string;
    postalCode: string;
    telephone: string;
    emailAddress: string;
    avatarUrl: string | undefined;
}

export class Investigator implements IInvestigator {
    uniqueID!: string;
    firstName!: string;
    lastName!: string;
    address!: string;
    address2!: string | undefined;
    city!: string;
    state!: string;
    postalCode!: string;
    telephone!: string;
    emailAddress!: string;
    avatarUrl!: string;

    constructor(data?: IInvestigator) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.uniqueID = _data["uniqueID"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.address = _data["address"];
            this.address2 = _data["address2"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.postalCode = _data["postalCode"];
            this.telephone = _data["telephone"];
            this.emailAddress = _data["emailAddress"];
            this.avatarUrl = _data["avatarUrl"];
        }
    }

    static fromJS(data: any): Investigator {
        data = typeof data === 'object' ? data : {};
        let result = new Investigator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["uniqueID"] = this.uniqueID;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["address"] = this.address;
        data["address2"] = this.address2;
        data["city"] = this.city;
        data["state"] = this.state;
        data["postalCode"] = this.postalCode;
        data["telephone"] = this.telephone;
        data["emailAddress"] = this.emailAddress;
        data["avatarUrl"] = this.avatarUrl;
        return data;
    }
}

export interface IInvestigator {
    uniqueID: string;
    firstName: string;
    lastName: string;
    address: string;
    address2: string | undefined;
    city: string;
    state: string;
    postalCode: string;
    telephone: string;
    emailAddress: string;
    avatarUrl: string;
}

export class CustomerCreateOrUpdate extends Base implements ICustomerCreateOrUpdate {
    name!: string;
    code!: string;
    firstName!: string;
    lastName!: string;
    address!: string;
    address2!: string | undefined;
    city!: string;
    state!: string;
    postalCode!: string;
    emailAddress!: string;
    telephone!: string;

    constructor(data?: ICustomerCreateOrUpdate) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.address = _data["address"];
            this.address2 = _data["address2"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.postalCode = _data["postalCode"];
            this.emailAddress = _data["emailAddress"];
            this.telephone = _data["telephone"];
        }
    }

    static fromJS(data: any): CustomerCreateOrUpdate {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerCreateOrUpdate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["address"] = this.address;
        data["address2"] = this.address2;
        data["city"] = this.city;
        data["state"] = this.state;
        data["postalCode"] = this.postalCode;
        data["emailAddress"] = this.emailAddress;
        data["telephone"] = this.telephone;
        super.toJSON(data);
        return data;
    }
}

export interface ICustomerCreateOrUpdate extends IBase {
    name: string;
    code: string;
    firstName: string;
    lastName: string;
    address: string;
    address2: string | undefined;
    city: string;
    state: string;
    postalCode: string;
    emailAddress: string;
    telephone: string;
}

export class InvestigatorCreateOrUpdate extends Base implements IInvestigatorCreateOrUpdate {
    firstName!: string;
    lastName!: string;
    address!: string;
    address2!: string | undefined;
    city!: string;
    state!: string;
    postalCode!: string;
    telephone!: string;
    emailAddress!: string;

    constructor(data?: IInvestigatorCreateOrUpdate) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.address = _data["address"];
            this.address2 = _data["address2"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.postalCode = _data["postalCode"];
            this.telephone = _data["telephone"];
            this.emailAddress = _data["emailAddress"];
        }
    }

    static fromJS(data: any): InvestigatorCreateOrUpdate {
        data = typeof data === 'object' ? data : {};
        let result = new InvestigatorCreateOrUpdate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["address"] = this.address;
        data["address2"] = this.address2;
        data["city"] = this.city;
        data["state"] = this.state;
        data["postalCode"] = this.postalCode;
        data["telephone"] = this.telephone;
        data["emailAddress"] = this.emailAddress;
        super.toJSON(data);
        return data;
    }
}

export interface IInvestigatorCreateOrUpdate extends IBase {
    firstName: string;
    lastName: string;
    address: string;
    address2: string | undefined;
    city: string;
    state: string;
    postalCode: string;
    telephone: string;
    emailAddress: string;
}

export class CustomerRegistration extends Base implements ICustomerRegistration {
    name!: string;
    firstName!: string;
    lastName!: string;
    address!: string;
    address2!: string | undefined;
    city!: string;
    state!: string;
    postalCode!: string;
    emailAddress!: string;
    telephone!: string;
    password!: string | undefined;
    googleCredential!: string | undefined;

    constructor(data?: ICustomerRegistration) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.address = _data["address"];
            this.address2 = _data["address2"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.postalCode = _data["postalCode"];
            this.emailAddress = _data["emailAddress"];
            this.telephone = _data["telephone"];
            this.password = _data["password"];
            this.googleCredential = _data["googleCredential"];
        }
    }

    static fromJS(data: any): CustomerRegistration {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerRegistration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["address"] = this.address;
        data["address2"] = this.address2;
        data["city"] = this.city;
        data["state"] = this.state;
        data["postalCode"] = this.postalCode;
        data["emailAddress"] = this.emailAddress;
        data["telephone"] = this.telephone;
        data["password"] = this.password;
        data["googleCredential"] = this.googleCredential;
        super.toJSON(data);
        return data;
    }
}

export interface ICustomerRegistration extends IBase {
    name: string;
    firstName: string;
    lastName: string;
    address: string;
    address2: string | undefined;
    city: string;
    state: string;
    postalCode: string;
    emailAddress: string;
    telephone: string;
    password: string | undefined;
    googleCredential: string | undefined;
}

export class Job extends Base implements IJob {
    id!: number;
    type!: JobType;
    status!: JobStatus;
    name!: string;
    description!: string;
    interval!: number;
    nextEvent!: Date | undefined;

    constructor(data?: IJob) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.status = _data["status"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.interval = _data["interval"];
            this.nextEvent = _data["nextEvent"] ? new Date(_data["nextEvent"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Job {
        data = typeof data === 'object' ? data : {};
        let result = new Job();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["status"] = this.status;
        data["name"] = this.name;
        data["description"] = this.description;
        data["interval"] = this.interval;
        data["nextEvent"] = this.nextEvent ? this.nextEvent.toISOString() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IJob extends IBase {
    id: number;
    type: JobType;
    status: JobStatus;
    name: string;
    description: string;
    interval: number;
    nextEvent: Date | undefined;
}

export enum JobType {
    RunDiagnostics = "RunDiagnostics",
    DeliverEmail = "DeliverEmail",
}

export enum JobStatus {
    Waiting = "Waiting",
    Running = "Running",
    Paused = "Paused",
}

export enum ErrorCode {
    Unknown = "Unknown",
    Unhandled = "Unhandled",
    NullReference = "NullReference",
    AccessDenied = "AccessDenied",
    NotImplemented = "NotImplemented",
    TimedOut = "TimedOut",
    EntityDoesNotExist = "EntityDoesNotExist",
    InvalidRequest = "InvalidRequest",
    FileNotFound = "FileNotFound",
    EntityFrameworkError = "EntityFrameworkError",
    RequestParameterNotExpectedInQueryString = "RequestParameterNotExpectedInQueryString",
    RequiredParameterNullOrEmpty = "RequiredParameterNullOrEmpty",
    ParameterCouldNotBeParsed = "ParameterCouldNotBeParsed",
    ParameterCouldNotBeParsedToEnum = "ParameterCouldNotBeParsedToEnum",
    RateLimitExceeded = "RateLimitExceeded",
    Blacklisted = "Blacklisted",
    EnumValueInvalid = "EnumValueInvalid",
    AnonymousInvocationNotAllowed = "AnonymousInvocationNotAllowed",
    ModelToDtoMappingNotSupported = "ModelToDtoMappingNotSupported",
    MethodAttributeMissing = "MethodAttributeMissing",
    MasterDataValueDoesNotExist = "MasterDataValueDoesNotExist",
    ApplicationSettingsInvalid = "ApplicationSettingsInvalid",
    ModelValidationFailed = "ModelValidationFailed",
    EmailDeliveryFailed = "EmailDeliveryFailed",
    AccountCredentialsInvalid = "AccountCredentialsInvalid",
    AccountExternalCredentialsInvalid = "AccountExternalCredentialsInvalid",
    AccountDoesNotExist = "AccountDoesNotExist",
    AccountLockedOut = "AccountLockedOut",
    AccountLockedOutOverride = "AccountLockedOutOverride",
    AccountTombstoned = "AccountTombstoned",
    AccountCredentialsExpired = "AccountCredentialsExpired",
    AccountRoleInvalidForOperation = "AccountRoleInvalidForOperation",
    AccountCredentialsNotConfirmed = "AccountCredentialsNotConfirmed",
    AccountEmailAddressInvalid = "AccountEmailAddressInvalid",
    AccountPasswordDoesNotMeetMinimumComplexity = "AccountPasswordDoesNotMeetMinimumComplexity",
    AccountEmailAddressAlreadyExists = "AccountEmailAddressAlreadyExists",
    AccountEmailAddressOrGuidInvalid = "AccountEmailAddressOrGuidInvalid",
    AccountEmailAddressNotConfirmed = "AccountEmailAddressNotConfirmed",
    AccountMagicUrlTokenMissing = "AccountMagicUrlTokenMissing",
    AccountMagicUrlTokenInvalid = "AccountMagicUrlTokenInvalid",
    AccountMagicUrlTokenExpired = "AccountMagicUrlTokenExpired",
    AccountStatusInvalidForOperation = "AccountStatusInvalidForOperation",
    AccountPasswordUsedPreviously = "AccountPasswordUsedPreviously",
    AccountAlreadyConfirmed = "AccountAlreadyConfirmed",
    AccountRequiresIdentityProviderLocal = "AccountRequiresIdentityProviderLocal",
    AccountRequiresIdentityProviderGoogle = "AccountRequiresIdentityProviderGoogle",
    AccountRequiresIdentityProviderApple = "AccountRequiresIdentityProviderApple",
    AccountRequiresIdentityProviderLinkedIn = "AccountRequiresIdentityProviderLinkedIn",
    JwtUnknownError = "JwtUnknownError",
    JwtRoleInvalid = "JwtRoleInvalid",
    JwtBearerTokenInvalid = "JwtBearerTokenInvalid",
    JwtClaimNotPresent = "JwtClaimNotPresent",
    JwtBearerTokenMissing = "JwtBearerTokenMissing",
    JwtClaimInvalid = "JwtClaimInvalid",
    JwtBearerTokenExpired = "JwtBearerTokenExpired",
    JwtRefreshTokenInvalid = "JwtRefreshTokenInvalid",
    GoogleJwtBearerTokenInvalid = "GoogleJwtBearerTokenInvalid",
    GoogleJwtNonceInvalid = "GoogleJwtNonceInvalid",
    CustomerDoesNotExist = "CustomerDoesNotExist",
    CustomerInvalid = "CustomerInvalid",
    CustomerCodeAlreadyExists = "CustomerCodeAlreadyExists",
    CustomerCodeGenerationFailed = "CustomerCodeGenerationFailed",
    InvestigatorDoesNotExist = "InvestigatorDoesNotExist",
}

function formatDate(d: Date) {
    return d.getFullYear() + '-' + 
        (d.getMonth() < 9 ? ('0' + (d.getMonth()+1)) : (d.getMonth()+1)) + '-' +
        (d.getDate() < 10 ? ('0' + d.getDate()) : d.getDate());
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}